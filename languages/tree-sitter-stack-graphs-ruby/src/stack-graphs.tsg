;; -*- coding: utf-8 -*-
;; ------------------------------------------------------------------------------------------------
;; Copyright Â© 2023, stack-graphs authors.
;; Licensed under either of Apache License, Version 2.0, or MIT license, at your option.
;; Please see the LICENSE-APACHE or LICENSE-MIT files in this distribution for license details.
;; ------------------------------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Stack graphs definition for Ruby
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Global Variables
;; ^^^^^^^^^^^^^^^^

global FILE_PATH
global ROOT_NODE
global JUMP_TO_SCOPE_NODE

;; Attribute Shorthands
;; ^^^^^^^^^^^^^^^^^^^^

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute symbol_definition = symbol    => type = "pop_symbol", symbol = symbol, is_definition
attribute symbol_reference = symbol     => type = "push_symbol", symbol = symbol, is_reference

attribute node_symbol = node            => symbol = (source-text node), source_node = node

;; Program
;; ^^^^^^^

(program)@prog {
    node @prog.defs
    node @prog.lexical_scope

    ;; program lexical scope inherits global scope
    edge @prog.lexical_scope -> ROOT_NODE

    ;; program lexical scope inherits global scope via the root
    ;; scope marker <::>
    node root_scope
    attr (root_scope) pop_symbol = "<::>"
    edge root_scope -> ROOT_NODE
    edge @prog.lexical_scope -> root_scope

    ;; top-level definitions are accessible from the global scope
    edge ROOT_NODE -> @prog.defs
}

(program (_)@stmt)@prog {
    ;; statements inherit program lexical scope
    edge @stmt.lexical_scope -> @prog.lexical_scope

    ;; program inherits statement definitions
    edge @prog.defs -> @stmt.instance_defs
    edge @prog.defs -> @stmt.root_defs
    edge @prog.defs -> @stmt.static_defs
}

;; Statements
;; ^^^^^^^^^^

[
    (class)
    (module)
    (uninterpreted)
]@stmt {
    node @stmt.instance_defs
    node @stmt.lexical_scope
    node @stmt.root_defs
    node @stmt.static_defs
}

[
    (class name:(_)@name)
    (module name:(_)@name)
]@class {
    ;; expose the class definition
    edge @class.root_defs -> @name.root_def
    edge @class.static_defs -> @name.static_def

    ;; resolve the class in the lexical scope
    edge @name.ref -> @class.lexical_scope
}

(class body:(_)@body) {
    node dot
    attr (dot) pop_symbol = "."

    node def
    attr (def) pop_symbol = "new"

    edge @body.static_defs -> dot
    edge dot -> def
    edge def -> @body.instance_defs
}

[
    (class name:(_)@name body:(_)@body)
    (module name:(_)@name body:(_)@body)
]@class {
    ;; body inherits class lexical scope
    edge @body.lexical_scope -> @class.lexical_scope

    ;; body inherits other definitions of this class
    edge @body.lexical_scope -> @name.ref_value

    ;; class body consists of body definitions
    edge @name.def_value -> @body.static_defs

    ;; root definitions are exposed upwards
    edge @class.root_defs -> @body.root_defs
}

(body_statement)@body {
    node @body.instance_defs
    node @body.lexical_scope
    node @body.root_defs
    node @body.static_defs
}

(body_statement (_)@stmt)@body {
    ;; statements inherits body lexical scope
    edge @stmt.lexical_scope -> @body.lexical_scope

    ;; body definitions consists of statement definitions
    edge @body.instance_defs -> @stmt.instance_defs
    edge @body.root_defs -> @stmt.root_defs
    edge @body.static_defs -> @stmt.static_defs
}

;; Expressions
;; ^^^^^^^^^^^

[
    (_primary/constant)
    (_primary/scope_resolution)
    (assignment)
    (call)
    (integer)
    (method)
    (singleton_method)
]@expr {
    node @expr.instance_defs
    node @expr.lexical_scope
    node @expr.root_defs
    node @expr.static_defs
    node @expr.value
}

[
    (_primary/constant)
    (_primary/identifier)
    (_primary/scope_resolution)
]@name {
    edge @name.ref -> @name.lexical_scope
    edge @name.value -> @name.ref_value
}

(assignment left:(_)@name right:(_)@value)@assign {
    edge @assign.root_defs -> @name.root_def
    edge @assign.static_defs -> @name.static_def

    edge @value.lexical_scope -> @assign.lexical_scope
}

(call receiver:(_)@recv method:(_)@mthd_name)@call {
    node dot
    attr (dot) push_symbol = "."

    edge @call.value -> @mthd_name.ref_value
    edge @mthd_name.ref -> dot
    edge dot -> @recv.value
    edge @recv.lexical_scope -> @call.lexical_scope
}

(method name:(_)@name)@method {
    node dot
    attr (dot) pop_symbol = "."

    node def
    attr (def) node_definition = @name

    edge @method.instance_defs -> dot
    edge dot -> def
}

(singleton_method name:(_)@name)@method {
    node dot
    attr (dot) pop_symbol = "."

    node def
    attr (def) node_definition = @name

    edge @method.static_defs -> dot
    edge dot -> def
}

;; Identifiers
;; ^^^^^^^^^^^

;; Identifiers are single or scoped names and can appear in reference
;; and definition positions. These rules create both reference and
;; definition nodes, and ensure both support arbitrarily deep nesting.
;;
;; The nodes available to connect the refences are:
;;     .ref         The reference. This node should be connected to the
;;                  lexical scope where the definition should resolve.
;;     .ref_value   The value the reference resolves to. References that
;;                  need to be resolved in this value should connect to
;;                  this node.
;;
;; The nodes available to connect the definitions are:
;;     .def         The definition. Scopes exposing the definition should
;;                  create an edge to this node.
;;     .def_value   The body of this definition. This node should be connected
;;                  to the definitions that are members of this definition.

[
    (constant)
    (identifier)
    (scope_resolution)
]@identifier {
    node @identifier.def_value
    node @identifier.ref
    node @identifier.ref_value
    node @identifier.root_def
    node @identifier.static_def
}

;;;; References
;;;; ``````````

(constant)@constant {
    node ref
    attr (ref) node_reference = @constant

    node scope_sep
    attr (scope_sep) push_symbol = "::"

    edge @constant.ref_value -> ref
    edge ref -> scope_sep
    edge scope_sep -> @constant.ref
}

(identifier)@identifier {
    node ref
    attr (ref) node_reference = @identifier

    edge @identifier.ref_value -> ref
    edge ref -> @identifier.ref
}

(scope_resolution scope:(_)@scope name:(_)@name)@scope_res {
    edge @scope_res.ref_value -> @name.ref_value
    edge @name.ref -> @scope.ref_value
    edge @scope.ref -> @scope_res.ref
}

(scope_resolution !scope name:(_)@name)@scope_res {
    node root_scope
    attr (root_scope) symbol_reference = "<::>"

    edge @scope_res.ref_value -> @name.ref_value
    edge @name.ref -> root_scope
    edge root_scope -> @scope_res.ref
}

;;;; Definitions
;;;; ```````````

(constant)@constant {
    node def
    attr (def) node_definition = @constant

    node scope_sep
    attr (scope_sep) pop_symbol = "::"

    edge @constant.static_def -> scope_sep
    edge scope_sep -> def
    edge def -> @constant.def_value
}

(scope_resolution scope:(_)@scope name:(_)@name)@scope_res {
    edge @scope_res.root_def -> @scope.root_def
    edge @scope_res.static_def -> @scope.static_def
    edge @scope.def_value -> @name.static_def
    edge @name.def_value -> @scope_res.def_value
}

(scope_resolution !scope name:(_)@name)@scope_res {
    edge @scope_res.root_def -> @name.static_def
    edge @name.def_value -> @scope_res.def_value
}

;; Comments
;; ^^^^^^^^

(comment)@comment {
    node @comment.def_value
    node @comment.instance_defs
    node @comment.lexical_scope
    node @comment.ref_value
    node @comment.root_def
    node @comment.root_defs
    node @comment.static_def
    node @comment.static_defs
}
