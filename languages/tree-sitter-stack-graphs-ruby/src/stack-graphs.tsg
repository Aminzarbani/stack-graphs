;; -*- coding: utf-8 -*-
;; ------------------------------------------------------------------------------------------------
;; Copyright Â© 2023, stack-graphs authors.
;; Licensed under either of Apache License, Version 2.0, or MIT license, at your option.
;; Please see the LICENSE-APACHE or LICENSE-MIT files in this distribution for license details.
;; ------------------------------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Stack graphs definition for Ruby
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Global Variables
;; ^^^^^^^^^^^^^^^^

global FILE_PATH
global ROOT_NODE
global JUMP_TO_SCOPE_NODE

;; Attribute Shorthands
;; ^^^^^^^^^^^^^^^^^^^^

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute symbol_definition = symbol    => type = "pop_symbol", symbol = symbol, is_definition
attribute symbol_reference = symbol     => type = "push_symbol", symbol = symbol, is_reference

attribute node_symbol = node            => symbol = (source-text node), source_node = node

;; Stack Graph Rules
;; ^^^^^^^^^^^^^^^^^

;; Program

(program)@prog {
    node @prog.defs
    node @prog.lexical_scope

    ;; program lexical scope inherits global scope
    edge @prog.lexical_scope -> ROOT_NODE

    ;; program lexical scope inherits global scope via the root
    ;; scope marker <::>
    node root_scope
    attr (root_scope) pop_symbol = "<::>"
    edge root_scope -> ROOT_NODE
    edge @prog.lexical_scope -> root_scope

    ;; top-level definitions are accessible from the global scope
    edge ROOT_NODE -> @prog.defs
}

(program (_)@stmt)@prog {
    edge @stmt.lexical_scope -> @prog.lexical_scope

    edge @prog.defs -> @stmt.defs
}

;; Statements

[
    (class)
    (uninterpreted)
]@stmt {
    node @stmt.defs
    node @stmt.lexical_scope
}

(class name:(constant)@name)@class {
    node @class.def
    attr (@class.def) node_definition = @name
    edge @class.defs -> @class.def
}

(class name:(scope_resolution scope:(_)@scope name:(_)@name))@class {
    node @scope.def
    attr (@scope.def) node_definition = @scope
    node @class.def
    attr (@class.def) node_definition = @name
    edge @class.defs -> @scope.def
    edge @scope.def -> @class.def
}

(class body:(_)@body)@class {
    edge @class.def -> @body.defs
}

(body_statement)@body {
    node @body.defs
    node @body.lexical_scope
}

(body_statement (_)@stmt)@body {
    edge @stmt.lexical_scope -> @body.lexical_scope

    edge @body.defs -> @stmt.defs
}

;; Expression

[
    (_primary/constant)
    (assignment)
    (integer)
    (scope_resolution)
]@expr {
    node @expr.defs
    node @expr.lexical_scope
    node @expr.type
}

[
    (assignment left:(constant)@name)
]@expr {
    node def
    attr (def) node_definition = @name
    edge @expr.defs -> def
}

(_expression/constant)@constant {
    node ref
    attr (ref) node_reference = @constant
    edge ref -> @constant.lexical_scope
}

(_primary/scope_resolution !scope name:(_)@name)@scope_res {
    node scope
    attr (scope) push_symbol = "<::>"
    edge scope -> @scope_res.lexical_scope

    node ref
    attr (ref) node_reference = @name
    edge ref -> scope
}

(_primary/scope_resolution scope:(constant)@name)@scope_res {
    node ref
    attr (ref) node_reference = @name
    edge ref -> @scope_res.lexical_scope

    edge @name.type -> ref
}

(_primary/scope_resolution scope:(_)@scope name:(_)@name)@scope_res {
    edge @scope.lexical_scope -> @scope_res.lexical_scope

    node ref
    attr (ref) node_reference = @name
    edge ref -> @scope.type

    edge @scope_res.type -> ref
}

;; Comments

(comment)@comment {
    node @comment.defs
    node @comment.lexical_scope
}
